
# ====== ui/src/app/api/game/[id]/state/route.ts ======
import { NextResponse } from "next/server";
import { getGame, updateGameTime } from "@/lib/gameStore";

export const dynamic = "force-dynamic";
export const revalidate = 0;

export async function GET(_: Request, ctx: { params: Promise<{ id: string }> }) {
  const { id } = await ctx.params;

  const game = getGame(id);
  if (!game) return NextResponse.json({ error: "Game not found" }, { status: 404 });

  const updatedGame = updateGameTime(id);
  if (!updatedGame) return NextResponse.json({ error: "Game not found" }, { status: 404 });

  return NextResponse.json(updatedGame, { headers: { "Cache-Control": "no-store" } });
}


# ====== ui/src/app/api/game/init/route.ts ======
import { NextResponse } from "next/server";
import { createGame } from "@/lib/gameStore";

export async function POST() {
  const game = createGame();
  return NextResponse.json({ game_id: game.game_id, message: "Game initialized" });
}

# ====== ui/src/app/api/game/spawn/route.ts ======
import { NextResponse } from "next/server";
import { spawnTroop } from "@/lib/gameStore";

export async function POST(req: Request) {
  const body = await req.json().catch(() => null);
  const { game_id, troop_type, position, team } = body || {};

  // Validation de surface
  if (
    typeof game_id !== "string" ||
    typeof troop_type !== "string" ||
    (team !== "red" && team !== "blue") ||
    !position ||
    typeof position.row !== "number" ||
    typeof position.col !== "number"
  ) {
    return NextResponse.json({ error: "Bad payload" }, { status: 400 });
  }

  try {
    const game = spawnTroop(game_id, troop_type, team, position);
    if (!game) return NextResponse.json({ error: "Game not found or invalid" }, { status: 404 });

    return NextResponse.json({
      success: true,
      message: `Spawned ${troop_type} for team ${team}`,
      state: game,
    });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "Spawn failed" }, { status: 422 });
  }
}

# ====== ui/src/app/api/match/create/route.ts ======
import { NextResponse } from 'next/server';
import { getSessionHeaders } from '@/lib/session';

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:3001';

export async function POST() {
  try {
    const headers = await getSessionHeaders();

    const response = await fetch(`${BACKEND_URL}/api/match/create`, {
      method: 'POST',
      headers,
    });

    const data = await response.json();

    if (!response.ok) {
      return NextResponse.json(data, { status: response.status });
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error('Error creating match:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to create match'
        },
        timestamp: Date.now()
      },
      { status: 500 }
    );
  }
}

# ====== ui/src/app/api/match/join/route.ts ======
import { NextRequest, NextResponse } from 'next/server';
import { getSessionHeaders } from '@/lib/session';

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:3001';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const headers = await getSessionHeaders();

    console.log('[Frontend API /join] Request to join match:', {
      matchId: body.matchId,
      playerId: headers['x-player-id'],
      playerName: headers['x-player-name']
    });

    const response = await fetch(`${BACKEND_URL}/api/match/join`, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });

    const data = await response.json();

    if (!response.ok) {
      console.error('[Frontend API /join] Backend error:', {
        status: response.status,
        error: data.error,
        matchId: body.matchId
      });
      return NextResponse.json(data, { status: response.status });
    }

    console.log('[Frontend API /join] Successfully joined match:', {
      matchId: body.matchId,
      team: data.data?.team,
      playerId: headers['x-player-id']
    });

    return NextResponse.json(data);
  } catch (error) {
    console.error('[Frontend API /join] Error joining match:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to join match'
        },
        timestamp: Date.now()
      },
      { status: 500 }
    );
  }
}

# ====== ui/src/app/api/match/list/route.ts ======
import { NextResponse } from 'next/server';
import { getSessionHeaders } from '@/lib/session';

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:3001';

export async function GET() {
  try {
    const headers = await getSessionHeaders();

    const response = await fetch(`${BACKEND_URL}/api/match`, {
      method: 'GET',
      headers,
    });

    const data = await response.json();

    if (!response.ok) {
      return NextResponse.json(data, { status: response.status });
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error('Error listing matches:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'Failed to list matches'
        },
        timestamp: Date.now()
      },
      { status: 500 }
    );
  }
}

# ====== ui/src/app/api/mcp/[transport]/route.ts ======
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";

type JsonRpcReq = { jsonrpc?: "2.0"; id?: number | string | null; method: string; params?: any };

const tools = [
  { name: "start_game", description: "Démarre une nouvelle partie de Clash Royale", inputSchema: { type: "object", properties: {}, required: [] } },
  {
    name: "deploy_troop",
    description: "Déploie une troupe sur le terrain de bataille",
    inputSchema: {
      type: "object",
      properties: {
        game_id: { type: "string" },
        troop_type: { type: "string", enum: ["GIANT", "BABY_DRAGON", "MINI_PEKKA", "VALKYRIE"] },
        position: { type: "object", properties: { row: { type: "number" }, col: { type: "number" } }, required: ["row", "col"] },
        team: { type: "string", enum: ["red", "blue"] },
      },
      required: ["game_id", "troop_type", "position", "team"],
    },
  },
  { name: "get_game_state", description: "Récupère l'état actuel du jeu (troupes, tours, statistiques)", inputSchema: { type: "object", properties: { game_id: { type: "string" } }, required: ["game_id"] } },
  {
    name: "analyze_strategy",
    description: "Analyse une stratégie Clash Royale",
    inputSchema: { type: "object", properties: { situation: { type: "string" } }, required: ["situation"] },
  },
];

async function proxyApi(path: string, options: RequestInit) {
  const base = process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
  const res = await fetch(`${base}${path}`, options);
  const text = await res.text();
  try { return JSON.parse(text); } catch { return { error: "Invalid JSON", raw: text }; }
}

async function executeTool(name: string, args: any) {
  switch (name) {
    case "start_game": {
      const data = await proxyApi("/api/game/init", { method: "POST" });
      return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
    }
    case "deploy_troop": {
      const data = await proxyApi("/api/game/spawn", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(args) });
      return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
    }
    case "get_game_state": {
      const gameId = args?.game_id;
      const data = await proxyApi(`/api/game/${gameId}/state`, { method: "GET" });
      return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
    }
    case "analyze_strategy": {
      return { content: [{ type: "text", text: JSON.stringify({ situation: args.situation, recommendation: "Analyse côté serveur à brancher" }, null, 2) }] };
    }
    default: throw new Error(`Unknown tool: ${name}`);
  }
}

function jsonRpcResult(id: any, result: any) { return NextResponse.json({ jsonrpc: "2.0", id: id ?? null, result }); }
function jsonRpcError(id: any, code: number, message: string) { return NextResponse.json({ jsonrpc: "2.0", id: id ?? null, error: { code, message } }); }

export async function POST(req: NextRequest) {
  try {
    const body = (await req.json()) as JsonRpcReq;
    const { id, method, params } = body;
    if (method === "server/info") return jsonRpcResult(id, { name: "clash-royale-mcp", version: "1.0.0", capabilities: { tools: {} } });
    if (method === "tools/list") return jsonRpcResult(id, { tools });
    if (method === "tools/call") {
      const { name, arguments: args } = params ?? {};
      if (!name) return jsonRpcError(id, -32602, "Missing tool name");
      try { return jsonRpcResult(id, await executeTool(name, args ?? {})); }
      catch (e: any) { return jsonRpcError(id, -32000, e?.message ?? "Tool error"); }
    }
    return jsonRpcError(id, -32601, "Method not found");
  } catch { return jsonRpcError(null, -32700, "Parse error"); }
}

export function GET() { return NextResponse.json({ ok: true, endpoint: "MCP streamable" }); }

# ====== ui/src/app/arena/page.tsx ======
"use client";

import { Button } from "@/components/ui/button";
import React, { useState, useEffect, Suspense } from "react";
import { useSearchParams, useRouter } from 'next/navigation';
import { useGameEngine } from "@/game/useGameEngine";
import { useOnlineGame } from "@/hooks/useOnlineGame";

import TowerHealthBar from "@/components/TowerHealthBar";
import ClashTimer from "@/components/ClashTimer";
import GameEndScreen from "@/components/GameEndScreen";
import { TroopType, TROOP_CONFIGS } from "@/game/types/Troop";
import { gameEngine } from "@/game/GameEngine";
import { GameStatus } from "@/types/backend";
import { GameState } from "@/game/GameEngine";

function ArenaContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const isOnlineMode = searchParams.get('mode') === 'online';
  const [onlineMatchId, setOnlineMatchId] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);


  const showGrid = false;
  const numRows = 34;
  const numCols = 18;

  const [currentTeam, setCurrentTeam] = useState<'red' | 'blue'>('red');
  const [draggedCard, setDraggedCard] = useState<{troopType: TroopType, team: 'red' | 'blue'} | null>(null);
  const params = useSearchParams();
  const gameId = params.get("game_id");
  const [gameState, setGameState] = useState<GameState | null>(null);

  const isArenaVisible = true;

  // Tour visuals (pour flags + sprites)
  const TOWER = React.useMemo(() => ({
    KING_RED: {
      id: 'king_red', name: 'King Red', image: '/images/towers/king_red.png',
      row: 2, col: 8, size: 6.5, offsetX: 1.4, offsetY: -2.8, team: 'red', type: 'king',
      flagged_cells: [[1,7],[1,8],[1,9],[1,10],[2,10],[2,9],[2,8],[2,7],[3,7],[3,8],[3,9],[3,10],[4,10],[4,9],[4,8],[4,7]],
      active: true,
    },
    PRINCESS_RED_1: {
      id: 'princess_red_left', name: 'Princess Red', image: '/images/towers/princess_red.png',
      row: 6, col: 3, size: 4, offsetX: -0.7, offsetY: -3.3, team: 'red', type: 'princess',
      flagged_cells: [[5,2],[5,3],[5,4],[6,4],[7,4],[7,3],[7,2],[6,2],[6,3]], active: true,
    },
    PRINCESS_RED_2: {
      id: 'princess_red_right', name: 'Princess Red', image: '/images/towers/princess_red.png',
      row: 6, col: 14, size: 4, offsetX: 0, offsetY: -3.3, team: 'red', type: 'princess',
      flagged_cells: [[5,13],[5,14],[5,15],[6,15],[6,14],[6,13],[7,13],[7,14],[7,15]], active: true,
    },
    PRINCESS_BLUE_1: {
      id: 'princess_blue_left', name: 'Princess Blue', image: '/images/towers/princess_blue.png',
      row: 27, col: 3, size: 7.4, offsetX: -0.4, offsetY: -2, team: 'blue', type: 'princess',
      flagged_cells: [[26,2],[26,3],[26,4],[27,4],[27,3],[27,2],[28,2],[28,3],[28,4]], active: true,
    },
    PRINCESS_BLUE_2: {
      id: 'princess_blue_right', name: 'Princess Blue', image: '/images/towers/princess_blue.png',
      row: 27, col: 14, size: 7.4, offsetX: 0, offsetY: -2, team: 'blue', type: 'princess',
      flagged_cells: [[26,13],[26,14],[26,15],[27,15],[27,14],[27,13],[28,13],[28,14],[28,15]], active: true,
    },
    KING_BLUE: {
      id: 'king_blue', name: 'King Blue', image: '/images/towers/king_blue.png',
      row: 31, col: 8, size: 6.5, offsetX: 1, offsetY: -2, team: 'blue', type: 'king',
      flagged_cells: [[30,7],[31,7],[32,7],[33,7],[33,8],[32,8],[31,8],[30,8],[30,9],[30,10],[31,10],[31,9],[32,9],[32,10],[33,10],[33,9]],
      active: true,
    }
  }), []);

  // Convertir TOWER en format compatible avec le moteur de jeu
  const towersForGame = Object.values(TOWER).map(tower => ({
    id: tower.id,
    type: tower.type as 'king' | 'princess',
    team: tower.team as 'red' | 'blue',
    row: tower.row,
    col: tower.col,
    health: tower.type === 'king' ? 4824 : 3052,
    maxHealth: tower.type === 'king' ? 4824 : 3052,
    isAlive: true,
    active: true,
    position: { row: tower.row, col: tower.col },
    offsetX: tower.offsetX,
    offsetY: tower.offsetY,
    lastAttackTime: 0,
    isAttacking: false,
    canAttack: true
  }));
  
  // Local game hook
  const localGame = useGameEngine(towersForGame, undefined);

  // Online game hook
  const onlineGame = useOnlineGame();

  // Initialize online game if in online mode
  useEffect(() => {
    if (isOnlineMode) {
      const matchId = sessionStorage.getItem('matchId');
      const isHost = sessionStorage.getItem('isHost') === 'true';
      const playerTeam = sessionStorage.getItem('playerTeam') as 'red' | 'blue' | null;

      if (matchId) {
        setOnlineMatchId(matchId);
        setIsConnecting(true);

        // Connect to the match
        if (isHost) {
          onlineGame.createMatch().then(success => {
            setIsConnecting(false);
            if (!success) {
              alert('Failed to create match');
              router.push('/lobby');
            }
          });
        } else {
          onlineGame.joinMatch(matchId).then(success => {
            setIsConnecting(false);
            if (!success) {
              alert('Failed to join match');
              router.push('/lobby');
            } else if (playerTeam) {
              setCurrentTeam(playerTeam);
            }
          });
        }
      } else {
        // No match ID, redirect to lobby
        router.push('/lobby');
      }
    } else {
      // Local mode - Initialize towers in GameEngine
      Object.values(TOWER).forEach(tower => {
        gameEngine.addTower(tower.id, tower.type as 'king' | 'princess', tower.team as 'red' | 'blue', tower.row, tower.col);
      });
    }

    return () => {
      if (isOnlineMode) {
        onlineGame.disconnect();
      } else {
        // Clean up towers on component destroy
        Object.values(TOWER).forEach(tower => {
          gameEngine.removeTower(tower.id);
        });
      }
    };
  }, [isOnlineMode]);

  // Use appropriate game based on mode
  const game = isOnlineMode ? onlineGame : localGame;
  const troops = game.troops;
  const gameEngineTowers = isOnlineMode ? game.towers : localGame.towers;
  const spawnTroop = isOnlineMode
    ? (type: TroopType, team: 'red' | 'blue', row: number, col: number) => {
        // In online mode, only allow spawning for player's team
        if (team === onlineGame.playerTeam) {
          onlineGame.spawnTroop(type, team, row, col);
        }
      }
    : localGame.spawnTroop;
  const startGame = isOnlineMode ? () => {} : localGame.startGame; // Online games start automatically
  const pauseGame = isOnlineMode ? onlineGame.pauseGame : localGame.pauseGame;
  const resumeGame = isOnlineMode ? onlineGame.resumeGame : localGame.resumeGame;
  const stopGame = isOnlineMode ? onlineGame.disconnect : localGame.stopGame;
  const resetGame = isOnlineMode ? () => router.push('/lobby') : localGame.resetGame;
  const isGameRunning = isOnlineMode
    ? onlineGame.gameStatus === GameStatus.IN_PROGRESS
    : localGame.isGameRunning;
  const isGamePaused = isOnlineMode
    ? onlineGame.gameStatus === GameStatus.PAUSED
    : localGame.isGamePaused;
  const gameEnded = isOnlineMode ? onlineGame.gameEnded : localGame.gameEnded;
  const winner = isOnlineMode ? onlineGame.winner : localGame.winner;

  // Fetch game state for local mode only
  React.useEffect(() => {
    if (!isOnlineMode && gameId) {
      const interval = setInterval(async () => {
        try {
          const res = await fetch(`/api/game/${gameId}/state`, { cache: "no-store" });
          if (!res.ok) return;
          const data = await res.json();
          if (!data || data.error) return;
          setGameState(data);
        } catch (error) {
          console.error("Failed to fetch game state:", error);
        }
      }, 500);

      return () => clearInterval(interval);
    }
  }, [gameId, isOnlineMode]);

  // Sync currentTeam with player's actual team in online mode
  React.useEffect(() => {
    if (isOnlineMode && onlineGame.playerTeam) {
      setCurrentTeam(onlineGame.playerTeam);
    }
  }, [isOnlineMode, onlineGame.playerTeam]);

  const handleCardDragStart = (troopType: TroopType) => {
    // In online mode, always use the player's actual team
    const team = isOnlineMode && onlineGame.playerTeam ? onlineGame.playerTeam : currentTeam;
    setDraggedCard({ troopType, team });
  };
  const handleCardDragEnd = () => setDraggedCard(null);
  
  const handleCellDrop = async (row: number, col: number, e: React.DragEvent) => {
    e.preventDefault();
    if (!draggedCard) return;

    if (isOnlineMode) {
      // Online mode: Use onlineGame to spawn troops
      if (onlineGame.playerTeam && draggedCard.team === onlineGame.playerTeam) {
        onlineGame.playCard(draggedCard.troopType, row, col);
        setDraggedCard(null);
      } else {
        console.warn("Cannot spawn troops for enemy team");
      }
    } else if (gameId) {
      // Local mode: Use API endpoint
      try {
        await fetch("/api/game/spawn", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            game_id: gameId,
            troop_type: draggedCard.troopType,
            position: { row, col },
            team: draggedCard.team,
          }),
        });
        setDraggedCard(null);
      } catch (error) {
        console.error("Failed to spawn troop:", error);
      }
    }
  };
  
  const handleCellDragOver = (e: React.DragEvent) => e.preventDefault();
  const switchTeam = () => setCurrentTeam(currentTeam === 'red' ? 'blue' : 'red');

  const normalizeType = (s: any): TroopType | null => {
    const u = String(s || "").toLowerCase();
    if (u === "giant") return TroopType.GIANT;
    if (u === "babydragon" || u === "baby_dragon") return TroopType.BABY_DRAGON;
    if (u === "minipekka" || u === "mini_pekka") return TroopType.MINI_PEKKA;
    if (u === "valkyrie") return TroopType.VALKYRIE;
    console.warn("Unknown troop.type from API:", s);
    return null;
  };

  const FALLBACK_WALK: Record<TroopType, {player: string; opponent: string}> = {
    [TroopType.GIANT]: { player: "/images/troops/giant/Giant_walk_player.gif", opponent: "/images/troops/giant/Giant_walk_opponent.gif" },
    [TroopType.BABY_DRAGON]: { player: "/images/troops/babydragon/BabyDragon_walk_player.gif", opponent: "/images/troops/babydragon/BabyDragon_walk_opponent.gif" },
    [TroopType.MINI_PEKKA]: { player: "/images/troops/minipekka/MiniPekka_walk_player.gif", opponent: "/images/troops/minipekka/MiniPekka_walk_opponent.gif" },
    [TroopType.VALKYRIE]: { player: "/images/troops/valkyrie/Valkyrie_walk_player.gif", opponent: "/images/troops/valkyrie/Valkyrie_walk_opponent.gif" },
  };

  const FALLBACK_FIGHT: Record<TroopType, {player: string; opponent: string}> = {
    [TroopType.GIANT]: { player: "/images/troops/giant/Giant_fight_player.gif", opponent: "/images/troops/giant/Giant_fight_opponent.gif" },
    [TroopType.BABY_DRAGON]: { player: "/images/troops/babydragon/BabyDragon_fight_player.gif", opponent: "/images/troops/babydragon/BabyDragon_fight_opponent.gif" },
    [TroopType.MINI_PEKKA]: { player: "/images/troops/minipekka/MiniPekka_fight_player.gif", opponent: "/images/troops/minipekka/MiniPekka_fight_opponent.gif" },
    [TroopType.VALKYRIE]: { player: "/images/troops/valkyrie/Valkyrie_fight_player.gif", opponent: "/images/troops/valkyrie/Valkyrie_fight_opponent.gif" },
  };

  const getTroopGifPath = (troop: any) => {
    const norm = normalizeType(troop?.type);
    if (!norm) return null;
    const gifType = troop.team === 'blue' ? 'player' : 'opponent';
    const cfg = TROOP_CONFIGS[norm];

    // Check if troop is in combat (attacking state)
    const isAttacking = troop.state === 'ATTACKING_TOWER' || troop.state === 12; // TroopState.ATTACKING_TOWER = 12

    // Select appropriate gif based on state
    const gifPaths = isAttacking ? cfg?.gifPaths?.fight : cfg?.gifPaths?.walk;
    const fallback = isAttacking ? FALLBACK_FIGHT[norm] : FALLBACK_WALK[norm];
    const fromConfig = gifPaths?.[gifType];

    return (typeof fromConfig === "string" && fromConfig.length > 0)
      ? `${fromConfig}?v=${troop.id}`
      : `${fallback[gifType]}?v=${troop.id}`;
  };

  const handleRestart = () => {
    router.push("/");
  };

  // Conditional rendering based on mode
  if (isOnlineMode) {
    if (isConnecting) {
      return <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">Connecting to match...</div>;
    }
    if (!onlineGame.isConnected && !isConnecting) {
      return <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">Connection failed. Redirecting...</div>;
    }
    // Check if game is waiting for players
    if (onlineGame.gameStatus === GameStatus.WAITING) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
          <div className="text-center">
            <h2 className="text-2xl font-bold mb-4">Waiting for opponent...</h2>
            <p className="text-gray-400">Match ID: {onlineGame.matchId}</p>
            <p className="text-gray-400 mt-2">Players: {onlineGame.players.length}/2</p>
            <div className="mt-4">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto"></div>
            </div>
          </div>
        </div>
      );
    }
  } else {
    // Local mode checks
    if (!gameId) return null;
    if (!gameState) return <div>Loading game...</div>;
  }

  // Get game data based on mode
  const gameTroops = isOnlineMode ? troops : (gameState?.troops ?? []);
  const gameTowers = isOnlineMode ?
    Object.values(TOWER).reduce((acc, tower) => {
      const engineTower = gameEngineTowers.find(t => t.id === tower.id);
      // Only include tower data if it exists in the engine
      if (engineTower) {
        return {
          ...acc,
          [tower.id]: {
            health: engineTower.health,
            maxHealth: engineTower.maxHealth, // Use camelCase for consistency
            isAlive: engineTower.isAlive,
            active: engineTower.active
          }
        };
      }
      return acc;
    }, {} as any) :
    gameState?.towers;

  return (
    <div className={`min-h-screen flex items-center justify-center relative overflow-hidden transition-opacity duration-1000 ${isArenaVisible ? 'opacity-100' : 'opacity-0'}`}>
      <img src="/images/backgrounds/arena_in_game.png" alt="Goal Background Blurred" className="absolute inset-0 w-full h-full object-cover blur-sm" />

      {(isOnlineMode ? gameEnded : gameState?.is_game_over) &&
       (isOnlineMode ? winner : gameState?.winner) &&
       <GameEndScreen winner={(isOnlineMode ? winner : gameState.winner) as "red" | "blue"} onRestart={handleRestart} />}

      <div className="relative w-[56.25vh] mb-10 h-screen max-w-full max-h-screen z-10">
        <img src="/images/backgrounds/arena_in_game.png" alt="Arena In Game" className="w-full h-full object-cover" />

        <div className="absolute inset-0 pl-[10%] pr-[9.8%] pt-[27.8%] pb-[34.2%]">
          <div className={`w-full h-full grid gap-0`} style={{ gridTemplateColumns: `repeat(${numCols}, 1fr)`, gridTemplateRows: `repeat(${numRows}, 1fr)` }}>
            {Array.from({ length: numRows * numCols }, (_, index) => {
              const row = Math.floor(index / numCols);
              const col = index % numCols;
              const isEven = (row + col) % 2 === 0;
              const towerPosition = Object.values(TOWER).find(pos => row === pos.row && col === pos.col);
              const shouldShowTower = !!towerPosition;
              const tower = towerPosition || null;

              return (
                <div
                  key={index}
                  className={`w-full h-full transition-all duration-200 relative ${!showGrid ? 'bg-transparent' : 'bg-black/20'}
                    ${
                      draggedCard 
                        ? `cursor-crosshair ${draggedCard.team === 'red' ? 'hover:bg-red-400/50 hover:ring-2 ring-red-400' : 'hover:bg-blue-400/50 hover:ring-2 ring-blue-400'}`
                        : 'cursor-default'
                    } ${
                      isEven ? 'bg-white/10 hover:bg-white/20 hover:ring-2 ring-yellow-400 ring-opacity-50'
                             : 'bg-black/20 hover:bg-black/30 hover:ring-2 ring-yellow-400 ring-opacity-50'
                    }`}
                  onDrop={(e) => handleCellDrop(row, col, e)}
                  onDragOver={handleCellDragOver}
                >
                  {/* Debug overlay minimal */}
                  {gameTroops.some(t => Math.floor(t.position.row) === row && Math.floor(t.position.col) === col) && (
                    <div className="absolute inset-0 z-30 pointer-events-none ring-2 ring-green-300/60"></div>
                  )}
                  
                  {shouldShowTower && (() => {
                    const engineTower = gameTowers?.[tower!.id];
                    // Check if tower exists and is alive
                    if (!engineTower || engineTower.health <= 0 || !engineTower.isAlive) {
                      return null; // Don't show destroyed towers
                    }

                    return (
                      <>
                        <img
                          src={tower!.image}
                          alt={tower!.name}
                          className="absolute inset-0 w-full h-full z-10 pointer-events-none object-contain"
                          style={{ transform: `scale(${tower!.size}) translate(${tower!.offsetX}px, ${tower!.offsetY}px)` }}
                        />
                        <div
                          className="absolute z-20 pointer-events-none"
                          style={{
                            left: `${(tower as any).offsetX - 16}px`,
                            top: `${
                              (tower as any).type === 'king'
                                ? ((tower as any).team === 'blue' ? 20 : -60)
                                : ((tower as any).team === 'blue' ? (tower as any).offsetY : (tower as any).offsetY - 40)
                            }px`,
                          }}
                        >
                          <TowerHealthBar
                            currentHealth={engineTower.health}
                            maxHealth={engineTower.maxHealth}
                            team={(tower as any).team}
                          />
                        </div>
                      </>
                    );
                  })()}

                  {gameTroops
                    .filter(t => {
                      const p = t?.position;
                      return p && Number.isFinite(p.row) && Number.isFinite(p.col)
                        && Math.floor(p.row) === row && Math.floor(p.col) === col;
                    })
                    .map(t => {
                      const norm = normalizeType(t.type);
                      if (!norm) return null;
                      const config = TROOP_CONFIGS[norm];
                      const gifPath = getTroopGifPath(t);
                      if (!gifPath || !config) return null;
                      const p = t.position;
                      const hp = typeof t.health === "number" ? t.health : 0;
                      const maxhp = typeof t.maxHealth === "number" && t.maxHealth > 0 ? t.maxHealth : 1;

                      return (
                        <div
                          key={t.id}
                          className="absolute z-20 w-full h-full flex items-center justify-center pointer-events-none"
                          style={{ transform: `translate(${(p.col - Math.floor(p.col)) * 100}%, ${(p.row - Math.floor(p.row)) * 100}%)` }}
                        >
                          <img
                            src={gifPath}
                            alt={`${norm} ${t.team}`}
                            className="w-12 h-12 object-contain"
                            style={{
                              transform: `scale(${
                                typeof config?.scale === 'object'
                                  ? ((t.state === 'ATTACKING_TOWER' || t.state === 12) ? (config.scale.fight ?? 1) : (config.scale.walk ?? 1))
                                  : (config?.scale ?? 1)
                              })`
                            }}
                          />
                          <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 w-8 h-1 bg-gray-600 rounded">
                            <div
                              className={`h-full rounded transition-all duration-200 ${t.team === 'red' ? 'bg-red-400' : 'bg-blue-400'}`}
                              style={{ width: `${(hp / maxhp) * 100}%` }}
                            />
                          </div>
                        </div>
                      );
                    })}
                </div>
              );
            })}
          </div>
        </div>

        <div className="absolute top-4 right-4 z-10">
          <ClashTimer
            gameTime={isOnlineMode ? onlineGame.gameTime : undefined}
            isOnlineMode={isOnlineMode}
          />
        </div>

        {/* Debug: affichage temporaire de tous les troops */}
        {(gameState?.troops ?? []).map(t => (
          <div key={t.id} className="absolute top-0 left-0 text-white bg-black p-1 text-xs z-50">
            {t.type} {t.team} @ {t.position.row},{t.position.col}
          </div>
        ))}

        {/* Barre de cartes */}
        <div className="fixed bottom-0 left-0 right-0 z-10">
          <div className="flex justify-center items-end pb-4">
            <div className="relative w-[80%] max-w-md">
              <img src="/images/cards/more/card_box.png" alt="Card Box" className="w-full h-44 object-fill rounded-t-lg" />
              <div className="absolute inset-0 grid grid-cols-4 gap-1.5 pl-[4.5%] pr-[4%] pb-[5.5%] items-stretch">
                {/* Baby Dragon */}
                <div
                  className={`w-full h-full transition-all duration-200 hover:scale-105 hover:z-10 relative rounded ${
                    !isGameRunning ? 'opacity-50 cursor-not-allowed' : 'cursor-grab active:cursor-grabbing hover:ring-2 hover:ring-yellow-400 hover:ring-opacity-80'
                  }`}
                  draggable={isGameRunning}
                  onDragStart={() => handleCardDragStart(TroopType.BABY_DRAGON)}
                  onDragEnd={handleCardDragEnd}
                >
                  <img src="/images/cards/more/BabyDragonCard.png" alt={`${currentTeam} Baby Dragon`} className="w-full h-full object-contain drop-shadow-lg pointer-events-none" />
                </div>

                {/* Mini PEKKA */}
                <div
                  className={`w-full h-full transition-all duration-200 hover:scale-105 hover:z-10 relative rounded ${
                    !isGameRunning ? 'opacity-50 cursor-not-allowed' : 'cursor-grab active:cursor-grabbing hover:ring-2 hover:ring-purple-400 hover:ring-opacity-80'
                  }`}
                  draggable={isGameRunning}
                  onDragStart={() => handleCardDragStart(TroopType.MINI_PEKKA)}
                  onDragEnd={handleCardDragEnd}
                >
                  <img src="/images/cards/more/MiniPEKKACard.png" alt={`${currentTeam} Mini PEKKA`} className="w-full h-full object-contain drop-shadow-lg pointer-events-none" />
                </div>

                {/* Giant */}
                <div
                  className={`w-full h-full transition-all duration-200 hover:scale-105 hover:z-10 relative rounded ${
                    !isGameRunning ? 'opacity-50 cursor-not-allowed' : 'cursor-grab active:cursor-grabbing hover:ring-2 hover:ring-orange-400 hover:ring-opacity-80'
                  }`}
                  draggable={isGameRunning}
                  onDragStart={() => handleCardDragStart(TroopType.GIANT)}
                  onDragEnd={handleCardDragEnd}
                >
                  <img src="/images/cards/more/GiantCard.png" alt={`${currentTeam} Giant`} className="w-full h-full object-contain drop-shadow-lg pointer-events-none" />
                </div>

                {/* Valkyrie */}
                <div
                  className={`w-full h-full transition-all duration-200 hover:scale-105 hover:z-10 relative rounded ${
                    !isGameRunning ? 'opacity-50 cursor-not-allowed' : 'cursor-grab active:cursor-grabbing hover:ring-2 hover:ring-red-400 hover:ring-opacity-80'
                  }`}
                  draggable={isGameRunning}
                  onDragStart={() => handleCardDragStart(TroopType.VALKYRIE)}
                  onDragEnd={handleCardDragEnd}
                >
                  <img src="/images/cards/more/ValkyrieCard.png" alt={`${currentTeam} Valkyrie`} className="w-full h-full object-contain drop-shadow-lg pointer-events-none" />
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Contrôles du jeu */}
        <div className="absolute top-4 left-4 z-10 space-y-2">
          {/* Online Mode Indicator */}
          {isOnlineMode && (
            <div className="bg-black/70 backdrop-blur-sm rounded-lg p-3 border border-purple-500/30">
              <div className="flex items-center gap-2 mb-2">
                <div className={`w-2 h-2 rounded-full ${
                  onlineGame.isConnected ? 'bg-green-500' :
                  isConnecting ? 'bg-yellow-500 animate-pulse' : 'bg-red-500'
                }`} />
                <span className="text-white text-sm font-semibold">
                  {onlineGame.isConnected ? 'Connected' :
                   isConnecting ? 'Connecting...' : 'Disconnected'}
                </span>
              </div>
              {onlineGame.playerTeam && (
                <div className="text-xs text-gray-300">
                  <p>Team: <span className={`font-bold ${
                    onlineGame.playerTeam === 'red' ? 'text-red-400' : 'text-blue-400'
                  }`}>{onlineGame.playerTeam.toUpperCase()}</span></p>
                  <p>Match: {onlineMatchId?.substring(0, 8)}</p>
                  <p>Elixir: {Math.floor(onlineGame.playerElixir)}/{10}</p>
                </div>
              )}
              <Button
                onClick={() => {
                  onlineGame.disconnect();
                  router.push('/lobby');
                }}
                variant="destructive"
                size="sm"
                className="w-full mt-2"
              >
                Leave Match
              </Button>
            </div>
          )}

          {/* Bouton pour switcher d'équipe (local mode only) */}
          {!isOnlineMode && (
          <Button
            variant="secondary"
            className={`font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg border-2 border-white/20 ${
              currentTeam === 'red' 
                ? 'bg-red-600 hover:bg-red-700 text-white' 
                : 'bg-blue-600 hover:bg-blue-700 text-white'
            }`}
            onClick={switchTeam}
          >
            Team: {currentTeam === 'red' ? 'Red' : 'Blue'}
          </Button>
          )}

          {/* Contrôles de jeu */}
          <div className="space-x-2">
            {!isGameRunning ? (
              <Button 
                variant="secondary" 
                className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg border-2 border-white/20"
                onClick={startGame}
              >
                Start Game
              </Button>
            ) : (
              <>
                {isGamePaused ? (
                  <Button 
                    variant="secondary" 
                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg border-2 border-white/20"
                    onClick={resumeGame}
                  >
                    Resume
                  </Button>
                ) : (
                  <Button 
                    variant="secondary" 
                    className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg border-2 border-white/20"
                    onClick={pauseGame}
                  >
                    Pause
                  </Button>
                )}
                <Button 
                  variant="secondary" 
                  className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow-lg border-2 border-white/20"
                  onClick={stopGame}
                >
                  Stop
                </Button>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

// Wrapper component with Suspense for Next.js
export default function Arena() {
  return (
    <Suspense fallback={
      <div className="min-h-screen bg-gradient-to-b from-blue-900 to-purple-900 flex items-center justify-center">
        <div className="text-white text-2xl animate-pulse">Loading Arena...</div>
      </div>
    }>
      <ArenaContent />
    </Suspense>
  );
}


# ====== ui/src/app/lobby/page.tsx ======
"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';
import { apiClient } from '@/services/api';
import { MatchInfo, GameStatus } from '@/types/backend';

export default function Lobby() {
  const router = useRouter();
  const [playerName, setPlayerName] = useState('');
  const [matchId, setMatchId] = useState('');
  const [matches, setMatches] = useState<MatchInfo[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Initialize with a default player name
  useEffect(() => {
    // Generate a random player name for this session
    setPlayerName(`Player_${Math.floor(Math.random() * 10000)}`);
  }, []);

  // Fetch available matches
  useEffect(() => {
    fetchMatches();
    const interval = setInterval(fetchMatches, 5000); // Refresh every 5 seconds
    return () => clearInterval(interval);
  }, []);

  const fetchMatches = async () => {
    try {
      const matchList = await apiClient.listMatches();
      setMatches(matchList.filter(m => m.status === GameStatus.WAITING));
    } catch (err) {
      console.error('Failed to fetch matches:', err);
    }
  };

  const handleCreateMatch = async () => {
    setLoading(true);
    setError(null);

    try {
      // Player name is now managed server-side via cookies
      // No need to update it here

      const response = await apiClient.createMatch();
      if (response) {
        // Store match ID and player info, then navigate to arena
        sessionStorage.setItem('matchId', response.matchId);
        sessionStorage.setItem('isHost', 'true');
        // Store the player ID from the response if available
        if (response.playerState) {
          sessionStorage.setItem('playerId', response.playerState.id);
          sessionStorage.setItem('playerName', response.playerState.name);
          sessionStorage.setItem('playerTeam', response.playerState.team);
        }
        router.push('/arena?mode=online');
      } else {
        setError('Failed to create match');
      }
    } catch (err) {
      setError('Failed to create match');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const handleJoinMatch = async (joinMatchId?: string) => {
    const targetMatchId = joinMatchId || matchId;
    if (!targetMatchId) {
      setError('Please enter a match ID');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      // Player name is now managed server-side via cookies
      // No need to update it here

      const response = await apiClient.joinMatch(targetMatchId);
      if (response) {
        // Store match ID and player info, then navigate to arena
        sessionStorage.setItem('matchId', targetMatchId);
        sessionStorage.setItem('isHost', 'false');
        sessionStorage.setItem('playerTeam', response.team);
        // Store the player ID from the response
        if (response.playerState) {
          sessionStorage.setItem('playerId', response.playerState.id);
          sessionStorage.setItem('playerName', response.playerState.name);
        }
        router.push('/arena?mode=online');
      } else {
        setError('Failed to join match');
      }
    } catch (err) {
      setError('Failed to join match - match may be full or not exist');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const getStatusColor = (status: GameStatus) => {
    switch (status) {
      case GameStatus.WAITING:
        return 'text-green-500';
      case GameStatus.IN_PROGRESS:
        return 'text-yellow-500';
      case GameStatus.ENDED:
        return 'text-red-500';
      default:
        return 'text-gray-500';
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-blue-900 to-purple-900 flex items-center justify-center p-4">
      <div className="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-2 gap-8">

        {/* Create/Join Section */}
        <Card className="p-8 bg-black/50 backdrop-blur border-purple-500/30">
          <h1 className="text-4xl font-bold text-white mb-8 text-center">
            🎮 Clash Royale Online
          </h1>

          {/* Player Name */}
          <div className="mb-6">
            <label className="text-white text-sm mb-2 block">Your Name</label>
            <Input
              type="text"
              placeholder="Enter your name"
              value={playerName}
              onChange={(e) => setPlayerName(e.target.value)}
              className="bg-black/50 border-purple-500/50 text-white"
            />
          </div>

          {/* Create Match */}
          <div className="mb-8">
            <h2 className="text-2xl font-bold text-white mb-4">Create New Match</h2>
            <Button
              onClick={handleCreateMatch}
              disabled={loading || !playerName}
              className="w-full bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white font-bold py-3"
            >
              {loading ? 'Creating...' : '⚔️ Create Match'}
            </Button>
          </div>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-purple-500/30"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="bg-transparent px-4 text-purple-300">OR</span>
            </div>
          </div>

          {/* Join Match */}
          <div className="mt-8">
            <h2 className="text-2xl font-bold text-white mb-4">Join Existing Match</h2>
            <div className="flex gap-2">
              <Input
                type="text"
                placeholder="Enter Match ID"
                value={matchId}
                onChange={(e) => setMatchId(e.target.value)}
                className="bg-black/50 border-purple-500/50 text-white"
              />
              <Button
                onClick={() => handleJoinMatch()}
                disabled={loading || !playerName}
                className="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white font-bold px-6"
              >
                {loading ? 'Joining...' : 'Join'}
              </Button>
            </div>
          </div>

          {/* Error Message */}
          {error && (
            <div className="mt-4 p-3 bg-red-500/20 border border-red-500/50 rounded text-red-300 text-sm">
              {error}
            </div>
          )}

          {/* Back Button */}
          <Button
            onClick={() => router.push('/')}
            variant="outline"
            className="w-full mt-6 border-purple-500/50 text-purple-300 hover:bg-purple-500/20"
          >
            ← Back to Home
          </Button>
        </Card>

        {/* Available Matches */}
        <Card className="p-8 bg-black/50 backdrop-blur border-purple-500/30">
          <h2 className="text-3xl font-bold text-white mb-6">Available Matches</h2>

          <div className="space-y-3 max-h-[500px] overflow-y-auto">
            {matches.length === 0 ? (
              <div className="text-center py-8 text-purple-300">
                <p className="text-lg mb-2">No matches available</p>
                <p className="text-sm opacity-75">Create a new match to start playing!</p>
              </div>
            ) : (
              matches.map((match) => (
                <div
                  key={match.id}
                  className="p-4 bg-black/30 rounded-lg border border-purple-500/30 hover:border-purple-500/50 transition-colors"
                >
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <p className="text-white font-semibold">
                        Match #{match.id.substring(0, 8)}
                      </p>
                      <p className={`text-sm ${getStatusColor(match.status)}`}>
                        {match.status}
                      </p>
                    </div>
                    <span className="text-purple-300 text-sm">
                      {match.playerCount}/{match.maxPlayers} players
                    </span>
                  </div>

                  {/* Players in match */}
                  {match.players.length > 0 && (
                    <div className="mb-3">
                      <p className="text-xs text-purple-300 mb-1">Players:</p>
                      <div className="flex gap-2">
                        {match.players.map((player) => (
                          <span
                            key={player.id}
                            className={`text-xs px-2 py-1 rounded ${
                              player.team === 'red'
                                ? 'bg-red-500/30 text-red-300'
                                : 'bg-blue-500/30 text-blue-300'
                            }`}
                          >
                            {player.name}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}

                  {match.playerCount < match.maxPlayers && (
                    <Button
                      onClick={() => handleJoinMatch(match.id)}
                      disabled={loading}
                      size="sm"
                      className="w-full bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800"
                    >
                      Join Match
                    </Button>
                  )}
                </div>
              ))
            )}
          </div>

          <div className="mt-6 p-4 bg-purple-500/10 rounded-lg border border-purple-500/30">
            <h3 className="text-white font-semibold mb-2">How to Play</h3>
            <ul className="text-sm text-purple-300 space-y-1">
              <li>• Create a match or join an existing one</li>
              <li>• Wait for another player to join</li>
              <li>• Battle starts automatically when room is full</li>
              <li>• Drag cards to deploy troops</li>
              <li>• Destroy enemy towers to win!</li>
            </ul>
          </div>
        </Card>
      </div>
    </div>
  );
}

# ====== ui/src/app/page.tsx ======
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import TransitionScreen from "@/components/TransitionScreen";

export default function Home() {
  const [showTransition, setShowTransition] = useState(false);
  const [gameMode, setGameMode] = useState<'local' | 'online' | null>(null);
  const router = useRouter();

  const handleLocalCombat = () => {
    setGameMode('local');
    setShowTransition(true);

  };

  const handleOnlineCombat = () => {
    router.push('/lobby');
  };

  return (
    <>
      <div className="min-h-screen flex items-center justify-center relative overflow-hidden">
        {/* Fond flou */}
        <img
          src="/images/backgrounds/goal.png"
          alt="Goal Background Blurred"
          className="absolute inset-0 w-full h-full object-cover blur-sm"
        />
        
        {/* Container avec ratio 9/16 */}
        <div className="relative w-[56.25vh] h-screen max-w-full max-h-screen z-10">
          <img
            src="/images/backgrounds/goal.png"
            alt="Goal Background"
            className="w-full h-full object-cover"
          />
          
          {/* Boutons de jeu */}
          <div className="absolute bottom-6 left-0 right-0 px-4">
            <div className="space-y-3">
              {/* Mode Local */}
              <Button
                onClick={handleLocalCombat}
                className="w-full bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600 text-white font-bold py-6 px-7 rounded-2xl text-xl transition-all duration-300 shadow-2xl border-4 border-yellow-300"
              >
                🎮 Combat Local
              </Button>

              {/* Mode Online */}
              <Button
                onClick={handleOnlineCombat}
                className="w-full bg-gradient-to-r from-purple-500 to-blue-600 hover:from-purple-600 hover:to-blue-700 text-white font-bold py-6 px-7 rounded-2xl text-xl transition-all duration-300 shadow-2xl border-4 border-purple-300"
              >
                🌐 Combat Online
              </Button>
            </div>
          </div>
        </div>
      </div>

      {/* Écran de transition */}
      {showTransition && gameMode === 'local' && (
        <TransitionScreen
          onTransitionComplete={() => {
            setShowTransition(false);
            router.push('/arena?mode=local');
          }}
        />
      )}
    </>
  );
}


# ====== ui/src/game/GameEngine.ts ======
import { GiantEntity, Giant } from './troops/Giant';
import { BabyDragonEntity, BabyDragon } from './troops/BabyDragon';
import { MiniPekkaEntity, MiniPekka } from './troops/MiniPekka';
import { ValkyrieEntity, Valkyrie } from './troops/Valkyrie';
import { BaseTroop, TroopEntity, TroopType } from './types/Troop';
import { TowerEntity, Tower } from './types/Tower';

export interface GameState {
  isRunning: boolean;
  isPaused: boolean;
  gameTime: number;
  lastUpdateTime: number;
}

export class GameEngine {
  protected troops: Map<string, TroopEntity> = new Map();
  protected towers: Map<string, TowerEntity> = new Map();
  protected gameState: GameState;
  private animationFrameId: number | null = null;
  protected onUpdateCallback?: (troops: BaseTroop[]) => void;
  protected onGameEndCallback?: (winner: 'red' | 'blue') => void;

  constructor() {
    this.gameState = {
      isRunning: false,
      isPaused: false,
      gameTime: 0,
      lastUpdateTime: 0
    };
  }

  public start(): void {
    if (this.gameState.isRunning) return;
    
    this.gameState.isRunning = true;
    this.gameState.isPaused = false;
    this.gameState.lastUpdateTime = performance.now();
    this.gameLoop();
  }

  public pause(): void {
    this.gameState.isPaused = true;
  }

  public resume(): void {
    if (!this.gameState.isRunning) return;
    
    this.gameState.isPaused = false;
    this.gameState.lastUpdateTime = performance.now();
    this.gameLoop();
  }

  public stop(): void {
    this.gameState.isRunning = false;
    this.gameState.isPaused = false;
    
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
    
    this.troops.clear();
    this.towers.clear();
  }

  public reset(): void {
    this.stop();
    this.gameState.gameTime = 0;
    this.gameState.lastUpdateTime = 0;
  }

  // Méthodes génériques pour les troupes
  public spawnTroop(type: TroopType, team: 'red' | 'blue', row?: number, col?: number): string {
    const id = `${type}_${team}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    let troop: TroopEntity;

    switch (type) {
      case TroopType.GIANT:
        troop = row !== undefined && col !== undefined 
          ? new GiantEntity(id, team, { row, col }) as unknown as TroopEntity
          : new GiantEntity(id, team) as unknown as TroopEntity;
        break;
      case TroopType.BABY_DRAGON:
        troop = row !== undefined && col !== undefined 
          ? new BabyDragonEntity(id, team, { row, col }) as unknown as TroopEntity
          : new BabyDragonEntity(id, team) as unknown as TroopEntity;
        break;
      case TroopType.MINI_PEKKA:
        troop = row !== undefined && col !== undefined 
          ? new MiniPekkaEntity(id, team, { row, col }) as unknown as TroopEntity
          : new MiniPekkaEntity(id, team) as unknown as TroopEntity;
        break;
      case TroopType.VALKYRIE:
        troop = row !== undefined && col !== undefined 
          ? new ValkyrieEntity(id, team, { row, col }) as unknown as TroopEntity
          : new ValkyrieEntity(id, team) as unknown as TroopEntity;
        break;
      default:
        throw new Error(`Unknown troop type: ${type}`);
    }

    this.troops.set(id, troop);
    console.log(`${type} spawned: ${id} for team ${team}${row !== undefined && col !== undefined ? ` at (${row}, ${col})` : ''}`);
    return id;
  }

  // Méthodes de compatibilité pour les anciens appels
  public spawnGiant(team: 'red' | 'blue'): string {
    return this.spawnTroop(TroopType.GIANT, team);
  }

  public spawnGiantAt(team: 'red' | 'blue', row: number, col: number): string {
    return this.spawnTroop(TroopType.GIANT, team, row, col);
  }

  public spawnBabyDragon(team: 'red' | 'blue', row: number, col: number): string {
    return this.spawnTroop(TroopType.BABY_DRAGON, team, row, col);
  }

  public spawnMiniPekka(team: 'red' | 'blue', row: number, col: number): string {
    return this.spawnTroop(TroopType.MINI_PEKKA, team, row, col);
  }

  public spawnValkyrie(team: 'red' | 'blue', row: number, col: number): string {
    return this.spawnTroop(TroopType.VALKYRIE, team, row, col);
  }

  public removeTroop(id: string): void {
    this.troops.delete(id);
  }

  // Méthodes pour les tours
  public addTower(id: string, type: 'king' | 'princess', team: 'red' | 'blue', row: number, col: number): void {
    const tower = new TowerEntity(id, type, team, row, col);
    this.towers.set(id, tower);
    console.log(`Tower ${type} added: ${id} for team ${team} at (${row}, ${col})`);
  }

  public removeTower(id: string): void {
    this.towers.delete(id);
  }

  public getTower(id: string): Tower | undefined {
    return this.towers.get(id)?.data;
  }

  public getTowerEntity(id: string): TowerEntity | undefined {
    return this.towers.get(id);
  }

  public getAllTowers(): Tower[] {
    return Array.from(this.towers.values()).map(tower => tower.data);
  }

  public getActiveTowers(): Tower[] {
    const allTowers = this.getAllTowers();
    const activeTowers = allTowers.filter(tower => tower.active && tower.isAlive);
    return activeTowers;
  }

  public getTroop(id: string): BaseTroop | undefined {
    return this.troops.get(id)?.data;
  }

  public getAllTroops(): BaseTroop[] {
    return Array.from(this.troops.values()).map(troop => troop.data);
  }

  public getTroopEntity(id: string): TroopEntity | undefined {
    return this.troops.get(id);
  }

  public getTroopsByType(type: TroopType): BaseTroop[] {
    return this.getAllTroops().filter(troop => troop.type === type);
  }

  public getLivingTroops(): BaseTroop[] {
    return this.getAllTroops().filter(troop => troop.isAlive);
  }

  // Méthodes de compatibilité
  public getAllGiants(): Giant[] {
    return this.getTroopsByType(TroopType.GIANT) as unknown as Giant[];
  }

  public getAllBabyDragons(): BabyDragon[] {
    return this.getTroopsByType(TroopType.BABY_DRAGON) as unknown as BabyDragon[];
  }

  public getAllMiniPekkas(): MiniPekka[] {
    return this.getTroopsByType(TroopType.MINI_PEKKA) as unknown as MiniPekka[];
  }

  public getAllValkyries(): Valkyrie[] {
    return this.getTroopsByType(TroopType.VALKYRIE) as unknown as Valkyrie[];
  }

  public getLivingGiants(): Giant[] {
    return this.getAllGiants().filter(giant => giant.isAlive);
  }

  public getLivingBabyDragons(): BabyDragon[] {
    return this.getAllBabyDragons().filter(dragon => dragon.isAlive);
  }

  public getLivingMiniPekkas(): MiniPekka[] {
    return this.getAllMiniPekkas().filter(pekka => pekka.isAlive);
  }

  public getLivingValkyries(): Valkyrie[] {
    return this.getAllValkyries().filter(valkyrie => valkyrie.isAlive);
  }

  public setOnUpdateCallback(callback: (troops: BaseTroop[]) => void): void {
    this.onUpdateCallback = callback;
  }

  public setOnGameEndCallback(callback: (winner: 'red' | 'blue') => void): void {
    this.onGameEndCallback = callback;
  }

  private gameLoop = (): void => {
    if (!this.gameState.isRunning || this.gameState.isPaused) {
      return;
    }

    const currentTime = performance.now();
    const deltaTime = (currentTime - this.gameState.lastUpdateTime) / 1000; // Convert to seconds
    
    this.update(deltaTime);
    
    this.gameState.lastUpdateTime = currentTime;
    this.gameState.gameTime += deltaTime;
    
    // Utiliser setTimeout pour l'environnement serveur, requestAnimationFrame pour le client
    if (typeof window !== 'undefined') {
      this.animationFrameId = requestAnimationFrame(this.gameLoop);
    } else {
      // Environnement serveur - utiliser setTimeout
      setTimeout(() => {
        this.gameLoop();
      }, 16); // ~60 FPS
    }
  };

  protected update(deltaTime: number): void {
    // Nettoyer les troupes mortes
    this.cleanupDeadTroops();
    
    // Mettre à jour toutes les troupes vivantes
    const activeTowers = this.getActiveTowersInternal();
    const flaggedCells = this.getFlaggedCells();
    
    for (const troop of this.troops.values()) {
      troop.update(deltaTime, activeTowers, flaggedCells, this);
    }

    // Mettre à jour les tours (attaque des ennemis)
    this.updateTowers(deltaTime);

    // Vérifier la fin de partie
    this.checkGameEnd();

    // Notifier les composants React
    if (this.onUpdateCallback) {
      this.onUpdateCallback(this.getAllTroops());
    }
  }

  protected updateTowers(deltaTime: number): void {
    const allTroops = this.getAllTroops();
    const allTowers = this.getActiveTowersInternal();

    for (const tower of this.towers.values()) {
      // Mettre à jour le statut canAttack pour les tours du roi
      tower.updateCanAttackStatus(allTowers);
      
      // Mettre à jour la tour (recherche de cibles et attaque)
      tower.update(deltaTime, allTroops, allTowers, this);
    }
  }

  protected cleanupDeadTroops(): void {
    const deadTroops = Array.from(this.troops.entries())
      .filter(([, troop]) => {
        // Add safety check for data property
        if (!troop || !troop.data) {
          console.warn('Troop missing data property:', troop);
          return false;
        }
        return !troop.data.isAlive;
      })
      .map(([id, ]) => id);

    for (const id of deadTroops) {
      this.troops.delete(id);
    }
  }

  private checkGameEnd(): void {
    // Vérifier si une King Tower est détruite
    const kingRed = this.towers.get('king_red');
    const kingBlue = this.towers.get('king_blue');

    // Add safety checks for tower data
    if (kingRed && kingRed.data && !kingRed.data.isAlive) {
      // King Rouge détruite → Bleu gagne
      console.log('Game Over: Blue team wins! King Red destroyed');
      this.endGame('blue');
    } else if (kingBlue && kingBlue.data && !kingBlue.data.isAlive) {
      // King Bleue détruite → Rouge gagne
      console.log('Game Over: Red team wins! King Blue destroyed');
      this.endGame('red');
    }
  }

  private endGame(winner: 'red' | 'blue'): void {
    this.gameState.isRunning = false;
    
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
    
    // Notifier la fin de partie
    if (this.onGameEndCallback) {
      this.onGameEndCallback(winner);
    }
  }

  private getActiveTowersInternal(): Tower[] {
    return this.getActiveTowers();
  }

  private getFlaggedCells(): Set<string> {
    // Cette fonction sera connectée avec les flagged cells de l'Arena
    return new Set<string>();
  }


  public connectFlaggedCells(flaggedCells: Set<string>): void {
    // Méthode pour connecter les flagged cells depuis Arena
    this.getFlaggedCells = () => flaggedCells;
  }

  // Méthode pour trouver l'ennemi le plus proche (troupe ou tour)
  public findClosestEnemy(troop: BaseTroop): { target: any, distance: number } | null {
    const activeTowers = this.getActiveTowersInternal();
    const enemyTroops = this.getAllTroops().filter(t => 
      t.team !== troop.team && t.isAlive
    );

    let closestTarget: any = null;
    let closestDistance = Infinity;

    // Vérifier les tours ennemies (toujours accessibles)
    activeTowers.forEach(tower => {
      if (tower.team !== troop.team) {
        const distance = Math.sqrt(
          Math.pow(tower.row - troop.position.row, 2) +
          Math.pow(tower.col - troop.position.col, 2)
        );
        if (distance < closestDistance) {
          closestDistance = distance;
          closestTarget = { ...tower, type: 'tower' };
        }
      }
    });

    // Vérifier les troupes ennemies (avec restriction flying vs non-flying et côté de la rivière)
    enemyTroops.forEach(enemyTroop => {
      // Non-flying troops cannot target flying troops
      if (!troop.flying && enemyTroop.flying) {
        return; // Skip flying troops for non-flying attackers
      }
      
      // Pour les troupes non-volantes, vérifier qu'elles sont du même côté de la rivière
      if (!troop.flying) {
        const frontierRow = 16;
        const troopSide = troop.position.row <= frontierRow ? 'top' : 'bottom';
        const enemySide = enemyTroop.position.row <= frontierRow ? 'top' : 'bottom';
        
        if (troopSide !== enemySide) {
          return; // Skip enemies on opposite side of river for non-flying troops
        }
      }
      
      const distance = Math.sqrt(
        Math.pow(enemyTroop.position.row - troop.position.row, 2) +
        Math.pow(enemyTroop.position.col - troop.position.col, 2)
      );
      if (distance < closestDistance) {
        closestDistance = distance;
        closestTarget = { ...enemyTroop, type: 'troop' };
      }
    });

    return closestTarget ? { target: closestTarget, distance: closestDistance } : null;
  }

  // Méthodes utilitaires pour les statistiques
  public getGameStats() {
    const allTroops = this.getAllTroops();
    const livingTroops = this.getLivingTroops();
    const giants = this.getAllGiants();
    const babyDragons = this.getAllBabyDragons();
    const miniPekkas = this.getAllMiniPekkas();
    const valkyries = this.getAllValkyries();
    
    return {
      totalTroops: allTroops.length,
      livingTroops: livingTroops.length,
      redTroops: allTroops.filter(t => t.team === 'red').length,
      blueTroops: allTroops.filter(t => t.team === 'blue').length,
      // Statistiques par type
      totalGiants: giants.length,
      livingGiants: giants.filter(g => g.isAlive).length,
      redGiants: giants.filter(g => g.team === 'red').length,
      blueGiants: giants.filter(g => g.team === 'blue').length,
      totalBabyDragons: babyDragons.length,
      livingBabyDragons: babyDragons.filter(d => d.isAlive).length,
      redBabyDragons: babyDragons.filter(d => d.team === 'red').length,
      blueBabyDragons: babyDragons.filter(d => d.team === 'blue').length,
      totalMiniPekkas: miniPekkas.length,
      livingMiniPekkas: miniPekkas.filter(p => p.isAlive).length,
      redMiniPekkas: miniPekkas.filter(p => p.team === 'red').length,
      blueMiniPekkas: miniPekkas.filter(p => p.team === 'blue').length,
      totalValkyries: valkyries.length,
      livingValkyries: valkyries.filter(v => v.isAlive).length,
      redValkyries: valkyries.filter(v => v.team === 'red').length,
      blueValkyries: valkyries.filter(v => v.team === 'blue').length,
      // État du jeu
      gameTime: this.gameState.gameTime,
      isRunning: this.gameState.isRunning,
      isPaused: this.gameState.isPaused
    };
  }
}

// Instance singleton du moteur de jeu
export const gameEngine = new GameEngine();

# ====== ui/src/game/useGameEngine.ts ======
import { useState, useEffect, useCallback } from 'react';
import { gameEngine } from './GameEngine';
import { Giant } from './troops/Giant';
import { BabyDragon } from './troops/BabyDragon';
import { MiniPekka } from './troops/MiniPekka';
import { Valkyrie } from './troops/Valkyrie';
import { BaseTroop, TroopType } from './types/Troop';
import { Tower } from './types/Tower';

export interface GameHookReturn {
  // Troupes génériques
  troops: BaseTroop[];
  // Troupes par type (pour compatibilité)
  giants: Giant[];
  babyDragons: BabyDragon[];
  miniPekkas: MiniPekka[];
  valkyries: Valkyrie[];
  // Tours avec leur santé mise à jour
  towers: Tower[];
  // État de fin de partie
  gameEnded: boolean;
  winner: 'red' | 'blue' | null;
  // Méthodes génériques
  spawnTroop: (type: TroopType, team: 'red' | 'blue', row: number, col: number) => void;
  // Méthodes spécifiques (pour compatibilité)
  spawnGiantAt: (team: 'red' | 'blue', row: number, col: number) => void;
  spawnBabyDragon: (team: 'red' | 'blue', row: number, col: number) => void;
  spawnMiniPekka: (team: 'red' | 'blue', row: number, col: number) => void;
  spawnValkyrie: (team: 'red' | 'blue', row: number, col: number) => void;
  // Contrôles du jeu
  gameStats: {
    totalTroops: number;
    livingTroops: number;
    redTroops: number;
    blueTroops: number;
    totalGiants: number;
    livingGiants: number;
    redGiants: number;
    blueGiants: number;
    totalBabyDragons: number;
    livingBabyDragons: number;
    redBabyDragons: number;
    blueBabyDragons: number;
    totalMiniPekkas: number;
    livingMiniPekkas: number;
    redMiniPekkas: number;
    blueMiniPekkas: number;
    totalValkyries: number;
    livingValkyries: number;
    redValkyries: number;
    blueValkyries: number;
    gameTime: number;
    isRunning: boolean;
    isPaused: boolean;
  };
  startGame: () => void;
  pauseGame: () => void;
  resumeGame: () => void;
  stopGame: () => void;
  resetGame: () => void;
  isGameRunning: boolean;
  isGamePaused: boolean;
}

export const useGameEngine = (towers?: Tower[], flaggedCells?: Set<string>): GameHookReturn => {
  const [troops, setTroops] = useState<BaseTroop[]>([]);
  const [giants, setGiants] = useState<Giant[]>([]);
  const [babyDragons, setBabyDragons] = useState<BabyDragon[]>([]);
  const [miniPekkas, setMiniPekkas] = useState<MiniPekka[]>([]);
  const [valkyries, setValkyries] = useState<Valkyrie[]>([]);
  const [gameTowers, setGameTowers] = useState<Tower[]>([]);
  const [gameStats, setGameStats] = useState(gameEngine.getGameStats());
  const [gameEnded, setGameEnded] = useState<boolean>(false);
  const [winner, setWinner] = useState<'red' | 'blue' | null>(null);

  // Mettre à jour les troupes et tours quand le moteur les modifie
  const handleGameUpdate = useCallback((updatedTroops: BaseTroop[]) => {
    setTroops([...updatedTroops]);
    // Séparer par type pour compatibilité
    setGiants([...updatedTroops.filter(t => t.type === TroopType.GIANT)] as unknown as Giant[]);
    setBabyDragons([...updatedTroops.filter(t => t.type === TroopType.BABY_DRAGON)] as unknown as BabyDragon[]);
    setMiniPekkas([...updatedTroops.filter(t => t.type === TroopType.MINI_PEKKA)] as unknown as MiniPekka[]);
    setValkyries([...updatedTroops.filter(t => t.type === TroopType.VALKYRIE)] as unknown as Valkyrie[]);
    // Mettre à jour les tours avec leur santé actuelle
    setGameTowers([...gameEngine.getAllTowers()]);
    setGameStats(gameEngine.getGameStats());
  }, []);

  // Gérer la fin de partie
  const handleGameEnd = useCallback((gameWinner: 'red' | 'blue') => {
    setGameEnded(true);
    setWinner(gameWinner);
  }, []);

  // Configurer le callback du moteur de jeu
  useEffect(() => {
    gameEngine.setOnUpdateCallback(handleGameUpdate);
    gameEngine.setOnGameEndCallback(handleGameEnd);
    
    return () => {
      gameEngine.setOnUpdateCallback(() => {});
      gameEngine.setOnGameEndCallback(() => {});
    };
  }, [handleGameUpdate, handleGameEnd]);

  // Connecter les flagged cells au moteur de jeu
  useEffect(() => {
    if (flaggedCells) {
      gameEngine.connectFlaggedCells(flaggedCells);
    }
  }, [flaggedCells]);

  // Fonctions de contrôle du jeu
  const spawnTroop = useCallback((type: TroopType, team: 'red' | 'blue', row: number, col: number) => {
    gameEngine.spawnTroop(type, team, row, col);
  }, []);

  const spawnGiantAt = useCallback((team: 'red' | 'blue', row: number, col: number) => {
    gameEngine.spawnGiantAt(team, row, col);
  }, []);

  const spawnBabyDragon = useCallback((team: 'red' | 'blue', row: number, col: number) => {
    gameEngine.spawnBabyDragon(team, row, col);
  }, []);

  const spawnMiniPekka = useCallback((team: 'red' | 'blue', row: number, col: number) => {
    gameEngine.spawnMiniPekka(team, row, col);
  }, []);

  const spawnValkyrie = useCallback((team: 'red' | 'blue', row: number, col: number) => {
    gameEngine.spawnValkyrie(team, row, col);
  }, []);

  const startGame = useCallback(() => {
    gameEngine.start();
    setGameStats(gameEngine.getGameStats());
  }, []);

  const pauseGame = useCallback(() => {
    gameEngine.pause();
    setGameStats(gameEngine.getGameStats());
  }, []);

  const resumeGame = useCallback(() => {
    gameEngine.resume();
    setGameStats(gameEngine.getGameStats());
  }, []);

  const stopGame = useCallback(() => {
    gameEngine.stop();
    setTroops([]);
    setGiants([]);
    setBabyDragons([]);
    setMiniPekkas([]);
    setValkyries([]);
    setGameStats(gameEngine.getGameStats());
  }, []);

  const resetGame = useCallback(() => {
    gameEngine.reset();
    setTroops([]);
    setGiants([]);
    setBabyDragons([]);
    setMiniPekkas([]);
    setValkyries([]);
    setGameStats(gameEngine.getGameStats());
    setGameEnded(false);
    setWinner(null);
    
    // Réinitialiser les tours à leur santé maximale
    if (towers) {
      towers.forEach(tower => {
        gameEngine.addTower(tower.id, tower.type, tower.team, tower.row, tower.col);
      });
    }
  }, [towers]);

  // Cleanup à la destruction du composant
  useEffect(() => {
    return () => {
      gameEngine.stop();
    };
  }, []);

  return {
    // Troupes génériques
    troops,
    // Troupes par type (pour compatibilité)
    giants,
    babyDragons,
    miniPekkas,
    valkyries,
    // Tours avec leur santé mise à jour
    towers: gameTowers,
    // État de fin de partie
    gameEnded,
    winner,
    // Méthodes génériques
    spawnTroop,
    // Méthodes spécifiques (pour compatibilité)
    spawnGiantAt,
    spawnBabyDragon,
    spawnMiniPekka,
    spawnValkyrie,
    // Contrôles du jeu
    gameStats,
    startGame,
    pauseGame,
    resumeGame,
    stopGame,
    resetGame,
    isGameRunning: gameStats.isRunning,
    isGamePaused: gameStats.isPaused
  };
};


# ====== ui/src/hooks/useOnlineGame.ts ======
import { useState, useEffect, useCallback, useRef } from 'react';
import { GameClient } from '@/services/gameClient';
import { ConnectionStatus } from '@/services/websocket';
import {
  GameSnapshot,
  GameStatus,
  TroopData,
  TowerData,
  PlayerState
} from '@/types/backend';
import { BaseTroop, TroopType } from '@/game/types/Troop';
import { Tower } from '@/game/types/Tower';

export interface OnlineGameHookReturn {
  // Connection
  connectionStatus: ConnectionStatus;
  isConnected: boolean;
  matchId: string | null;

  // Game state
  troops: BaseTroop[];
  towers: Tower[];
  players: PlayerState[];

  // Player state
  playerTeam: 'red' | 'blue' | null;
  playerElixir: number;
  playerState: PlayerState | null;

  // Game status
  gameStatus: GameStatus | null;
  gameTime: number;
  gameEnded: boolean;
  winner: 'red' | 'blue' | 'draw' | null;

  // Actions
  createMatch: () => Promise<boolean>;
  joinMatch: (matchId: string) => Promise<boolean>;
  spawnTroop: (type: TroopType, team: 'red' | 'blue', row: number, col: number) => void;
  playCard: (troopType: string, row: number, col: number) => void;
  pauseGame: () => void;
  resumeGame: () => void;
  surrender: () => void;
  disconnect: () => void;

  // Stats
  gameStats: {
    totalTroops: number;
    livingTroops: number;
    redTroops: number;
    blueTroops: number;
    gameTime: number;
    isRunning: boolean;
    isPaused: boolean;
  };
}

export const useOnlineGame = (): OnlineGameHookReturn => {
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('disconnected');
  const [snapshot, setSnapshot] = useState<GameSnapshot | null>(null);
  const [gameEnded, setGameEnded] = useState(false);
  const [winner, setWinner] = useState<'red' | 'blue' | 'draw' | null>(null);
  const gameClientRef = useRef<GameClient | null>(null);

  // Initialize game client
  useEffect(() => {
    if (!gameClientRef.current) {
      gameClientRef.current = new GameClient({
        onSnapshot: (newSnapshot) => {
          setSnapshot(newSnapshot);
        },
        onStatusChange: (status) => {
          setConnectionStatus(status);
        },
        onGameEnd: (gameWinner) => {
          setGameEnded(true);
          setWinner(gameWinner);
        },
        onError: (error) => {
          console.error('Game client error:', error);
        }
      });
    }

    return () => {
      gameClientRef.current?.destroy();
      gameClientRef.current = null;
    };
  }, []);

  // Match management
  const createMatch = useCallback(async (): Promise<boolean> => {
    if (!gameClientRef.current) return false;
    setGameEnded(false);
    setWinner(null);
    return await gameClientRef.current.createMatch();
  }, []);

  const joinMatch = useCallback(async (matchId: string): Promise<boolean> => {
    if (!gameClientRef.current) return false;
    setGameEnded(false);
    setWinner(null);
    return await gameClientRef.current.joinMatch(matchId);
  }, []);

  // Game actions
  const spawnTroop = useCallback((type: TroopType, team: 'red' | 'blue', row: number, col: number) => {
    if (!gameClientRef.current) return;

    // Only allow spawning for player's team
    const playerTeam = gameClientRef.current.getPlayerTeam();
    if (playerTeam !== team) {
      console.warn('Cannot spawn troops for enemy team');
      return;
    }

    gameClientRef.current.playCard(type, row, col);
  }, []);

  const playCard = useCallback((troopType: string, row: number, col: number) => {
    if (!gameClientRef.current) return;
    gameClientRef.current.playCard(troopType, row, col);
  }, []);

  const pauseGame = useCallback(() => {
    gameClientRef.current?.pauseGame();
  }, []);

  const resumeGame = useCallback(() => {
    gameClientRef.current?.resumeGame();
  }, []);

  const surrender = useCallback(() => {
    gameClientRef.current?.surrender();
  }, []);

  const disconnect = useCallback(() => {
    gameClientRef.current?.disconnect();
    setSnapshot(null);
    setConnectionStatus('disconnected');
  }, []);

  // Convert backend data to frontend format
  const convertTroops = (troopData: TroopData[]): BaseTroop[] => {
    return troopData.map(troop => ({
      id: troop.id,
      type: troop.type as TroopType,
      team: troop.team,
      position: troop.position,
      targetPosition: troop.targetPosition,
      state: troop.state as any,
      health: troop.health,
      maxHealth: troop.maxHealth,
      speed: troop.speed,
      isAlive: troop.isAlive,
      bridgeTarget: troop.bridgeTarget,
      towerTarget: troop.towerTarget,
      isInCombat: troop.isInCombat,
      attackDamage: troop.attackDamage,
      attackSpeed: troop.attackSpeed,
      lastAttackTime: troop.lastAttackTime,
      focusOnBuildings: troop.focusOnBuildings,
      flying: troop.flying,
      row: troop.row,
      col: troop.col
    }));
  };

  const convertTowers = (towerData: TowerData[]): Tower[] => {
    return towerData.map(tower => ({
      id: tower.id,
      type: tower.type,
      team: tower.team,
      row: tower.position.row,
      col: tower.position.col,
      health: tower.health,
      maxHealth: tower.maxHealth,
      isAlive: tower.isAlive,
      active: tower.active,
      position: tower.position
    }));
  };

  // Calculate game stats
  const gameStats = {
    totalTroops: snapshot?.troops.length || 0,
    livingTroops: snapshot?.troops.filter(t => t.isAlive).length || 0,
    redTroops: snapshot?.troops.filter(t => t.team === 'red' && t.isAlive).length || 0,
    blueTroops: snapshot?.troops.filter(t => t.team === 'blue' && t.isAlive).length || 0,
    gameTime: snapshot?.gameTime || 0,
    isRunning: snapshot?.status === GameStatus.IN_PROGRESS,
    isPaused: snapshot?.status === GameStatus.PAUSED
  };

  return {
    // Connection
    connectionStatus,
    isConnected: connectionStatus === 'connected',
    matchId: gameClientRef.current?.getMatchId() || null,

    // Game state
    troops: snapshot ? convertTroops(snapshot.troops) : [],
    towers: snapshot ? convertTowers(snapshot.towers) : [],
    players: snapshot?.players || [],

    // Player state
    playerTeam: gameClientRef.current?.getPlayerTeam() || null,
    playerElixir: gameClientRef.current?.getPlayerElixir() || 0,
    playerState: gameClientRef.current?.getPlayerState() || null,

    // Game status
    gameStatus: snapshot?.status || null,
    gameTime: snapshot?.gameTime || 0,
    gameEnded,
    winner,

    // Actions
    createMatch,
    joinMatch,
    spawnTroop,
    playCard,
    pauseGame,
    resumeGame,
    surrender,
    disconnect,

    // Stats
    gameStats
  };
};

# ====== ui/src/lib/gameStore.ts ======
// src/lib/gameStore.ts
import { v4 as uuidv4 } from "uuid";

export type TroopType = "GIANT" | "BABY_DRAGON" | "MINI_PEKKA" | "VALKYRIE";
export type Team = "red" | "blue";

const BOARD_ROWS = 34;
const BOARD_COLS = 18;

function isValidTroopType(x: unknown): x is TroopType {
  return x === "GIANT" || x === "BABY_DRAGON" || x === "MINI_PEKKA" || x === "VALKYRIE";
}
function isValidTeam(x: unknown): x is Team {
  return x === "red" || x === "blue";
}
function isValidPosition(p: any): p is { row: number; col: number } {
  return p && Number.isFinite(p.row) && Number.isFinite(p.col);
}
function clamp(n: number, min: number, max: number) {
  return Math.min(max, Math.max(min, n));
}
function sanitizePosition(pos: { row: number; col: number }) {
  // Discrétise sur la grille et clamp dans les bornes
  const row = clamp(Math.floor(pos.row), 0, BOARD_ROWS - 1);
  const col = clamp(Math.floor(pos.col), 0, BOARD_COLS - 1);
  return { row, col };
}

export interface Troop {
  id: string;
  type: TroopType;
  team: Team;
  position: { row: number; col: number };
  health: number;
  max_health: number;
  spawned_at: string;
  speed: number;              // cellules par seconde
  dir: { dr: number; dc: number }; // direction unitaire
}

export interface Tower {
  id: string;
  team: Team;
  type: "king" | "princess";
  health: number;
  max_health: number;
  position: { row: number; col: number };
}

export interface GameState {
  game_id: string;
  troops: Troop[];
  towers: Record<string, Tower>;
  elixir: { red: number; blue: number };
  max_elixir: number;
  elixir_rate: number;
  available_cards: TroopType[];
  game_time: number;
  start_time: string;
  is_game_over: boolean;
  winner: string | null;
  tactical_analysis: string;
  last_update_ms: number; // timestamp ms du dernier tick serveur
}

const games = new Map<string, GameState>();

function defaultTowers(): Record<string, Tower> {
  return {
    king_red:   { id: "king_red",   team: "red",  type: "king",     health: 100, max_health: 100, position: { row: 2,  col: 8 } },
    princess_red_left:  { id: "princess_red_left",  team: "red",  type: "princess", health: 100, max_health: 100, position: { row: 6,  col: 3 } },
    princess_red_right: { id: "princess_red_right", team: "red",  type: "princess", health: 100, max_health: 100, position: { row: 6,  col: 14 } },
    king_blue:  { id: "king_blue",  team: "blue", type: "king",     health: 100, max_health: 100, position: { row: 31, col: 8 } },
    princess_blue_left: { id: "princess_blue_left", team: "blue", type: "princess", health: 100, max_health: 100, position: { row: 27, col: 3 } },
    princess_blue_right:{ id: "princess_blue_right",team: "blue", type: "princess", health: 100, max_health: 100, position: { row: 27, col: 14 } },
  };
}

export function createGame(): GameState {
  const now = Date.now();
  const id = uuidv4();
  const state: GameState = {
    game_id: id,
    troops: [],
    towers: defaultTowers(),
    elixir: { red: 5, blue: 5 },
    max_elixir: 10,
    elixir_rate: 1,
    available_cards: ["GIANT", "BABY_DRAGON", "MINI_PEKKA", "VALKYRIE"],
    game_time: 0,
    start_time: new Date(now).toISOString(),
    is_game_over: false,
    winner: null,
    tactical_analysis: "Equal troop count on battlefield. Early game: Focus on elixir trades and chip damage",
    last_update_ms: now,
  };
  games.set(id, state);
  return state;
}

export function getGame(id: string): GameState | null {
  return games.get(id) || null;
}

// Invariant durci: aucune troupe n'est insérée sans position valide.
export function spawnTroop(
  id: string,
  troop_type: unknown,
  team: unknown,
  position: unknown
): GameState | null {
  const game = games.get(id);
  if (!game) return null;

  if (!isValidTroopType(troop_type)) throw new Error("Invalid troop_type");
  if (!isValidTeam(team)) throw new Error("Invalid team");
  if (!isValidPosition(position)) throw new Error("Invalid position");

  const pos = sanitizePosition(position);
  // NE PAS re-floor par la suite, on veut des floats qui bougent

  const baseSpeeds: Record<TroopType, number> = {
    GIANT: 1.2,        // ~1.2 cellules/sec
    BABY_DRAGON: 1.6,
    MINI_PEKKA: 1.8,
    VALKYRIE: 1.5,
  };

  const dir = (team === "red") ? { dr: +1, dc: 0 } : { dr: -1, dc: 0 };

  const costs: Record<TroopType, number> = {
    GIANT: 5,
    BABY_DRAGON: 4,
    MINI_PEKKA: 3,
    VALKYRIE: 4,
  };

  if (game.elixir[team] < costs[troop_type]) {
    // Pas d'insertion si elixir insuffisant
    return game;
  }

  const troop: Troop = {
    id: `${troop_type}_${team}_${game.troops.length}_${Math.random().toString(16).slice(2, 8)}`,
    type: troop_type,
    team,
    position: { row: pos.row, col: pos.col }, // garder floats
    health: 100,
    max_health: 100,
    spawned_at: new Date().toISOString(),
    speed: baseSpeeds[troop_type],
    dir,
  };

  game.troops.push(troop);
  game.elixir[team] -= costs[troop_type];
  games.set(id, game);
  return game;
}

export function updateGameTime(id: string): GameState | null {
  const game = games.get(id);
  if (!game) return null;

  const nowMs = Date.now();
  const dt = Math.max(0, (nowMs - game.last_update_ms) / 1000); // en secondes
  game.last_update_ms = nowMs;

  // Temps de jeu à partir du start + dt pour robustesse
  const startTime = new Date(game.start_time).getTime();
  game.game_time = Math.floor((nowMs - startTime) / 1000);

  // Regen d'élixir
  const regen = game.elixir_rate * 0.1;
  game.elixir.red = Math.min(game.max_elixir, game.elixir.red + regen);
  game.elixir.blue = Math.min(game.max_elixir, game.elixir.blue + regen);

  // Mouvement simple des troupes: avance tout droit vers la King Tower adverse
  for (const t of game.troops) {
    if (t.health <= 0) continue;

    // cible colonne de la king adverse pour un léger recentrage horizontal
    const targetCol = (t.team === "red") ? game.towers.king_blue.position.col
                                         : game.towers.king_red.position.col;

    // correction latérale douce vers la colonne cible
    const dc = Math.sign(targetCol - t.position.col) * 0.2; // 0.2 cell/s max en latéral
    const dr = t.dir.dr;                                     // avance principale

    const stepR = (dr) * t.speed * dt;
    const stepC = (dc) * dt;

    t.position.row = clamp(t.position.row + stepR, 0, BOARD_ROWS - 1);
    t.position.col = clamp(t.position.col + stepC, 0, BOARD_COLS - 1);

    // stop si atteint la ligne de la king adverse
    const goalRow = (t.team === "red") ? game.towers.king_blue.position.row
                                       : game.towers.king_red.position.row;
    if (Math.abs(t.position.row - goalRow) < 0.5) {
      t.speed = 0; // s'arrête pour l'instant
    }
  }

  games.set(id, game);
  return game;
}


# ====== ui/src/lib/session.ts ======
import { cookies } from 'next/headers';
import { v4 as uuidv4 } from 'uuid';

const PLAYER_ID_COOKIE = 'player_id';
const PLAYER_NAME_COOKIE = 'player_name';

export async function getOrCreatePlayerId(): Promise<string> {
  const cookieStore = await cookies();
  let playerId = cookieStore.get(PLAYER_ID_COOKIE)?.value;

  if (!playerId) {
    // Generate a unique player ID using UUID v4
    playerId = `player_${uuidv4()}`;
    console.log(`[Session] Creating new player ID: ${playerId}`);
    cookieStore.set(PLAYER_ID_COOKIE, playerId, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 days
      path: '/'
    });
  } else {
    console.log(`[Session] Using existing player ID: ${playerId}`);
  }

  return playerId;
}

export async function getOrCreatePlayerName(): Promise<string> {
  const cookieStore = await cookies();
  let playerName = cookieStore.get(PLAYER_NAME_COOKIE)?.value;

  if (!playerName) {
    playerName = `Player_${Math.floor(Math.random() * 10000)}`;
    cookieStore.set(PLAYER_NAME_COOKIE, playerName, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 days
      path: '/'
    });
  }

  return playerName;
}

export async function setPlayerName(name: string): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.set(PLAYER_NAME_COOKIE, name, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 7 days
    path: '/'
  });
}

export async function getSessionHeaders() {
  const playerId = await getOrCreatePlayerId();
  const playerName = await getOrCreatePlayerName();

  return {
    'x-player-id': playerId,
    'x-player-name': playerName,
    'Content-Type': 'application/json'
  };
}

# ====== ui/src/lib/utils.ts ======
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


# ====== ui/src/services/api.ts ======
import {
  ApiResponse,
  CreateMatchResponse,
  JoinMatchResponse,
  MatchInfo,
  GameSnapshot,
  PlayCardData
} from '@/types/backend';

// Use relative URLs to call Next.js API routes
// The session management is now handled server-side

class ApiClient {
  private baseUrl: string;

  constructor() {
    // Use relative URLs for Next.js API routes
    this.baseUrl = '';
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${endpoint}`;

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        // Include cookies for session management
        credentials: 'same-origin'
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error?.message || 'Request failed');
      }

      return data;
    } catch (error) {
      console.error('API request failed:', error);
      return {
        success: false,
        error: {
          code: 'REQUEST_FAILED',
          message: error instanceof Error ? error.message : 'Unknown error'
        },
        timestamp: Date.now()
      };
    }
  }

  // Match Management
  async createMatch(): Promise<CreateMatchResponse | null> {
    const response = await this.request<CreateMatchResponse>('/api/match/create', {
      method: 'POST',
    });

    if (response.success && response.data) {
      return response.data;
    }
    return null;
  }

  async joinMatch(matchId: string): Promise<JoinMatchResponse | null> {
    const response = await this.request<JoinMatchResponse>('/api/match/join', {
      method: 'POST',
      body: JSON.stringify({ matchId }),
    });

    if (response.success && response.data) {
      return response.data;
    }
    return null;
  }

  async getMatchInfo(matchId: string): Promise<MatchInfo | null> {
    const response = await this.request<MatchInfo>(`/api/match/${matchId}`);

    if (response.success && response.data) {
      return response.data;
    }
    return null;
  }

  async listMatches(): Promise<MatchInfo[]> {
    const response = await this.request<{ matches: MatchInfo[] }>('/api/match/list');

    if (response.success && response.data) {
      return response.data.matches;
    }
    return [];
  }

  // Game Actions
  async playCard(
    matchId: string,
    troopType: string,
    position: { row: number; col: number }
  ): Promise<boolean> {
    const response = await this.request('/api/game/play_card', {
      method: 'POST',
      body: JSON.stringify({
        matchId,
        troopType,
        position,
      }),
    });

    return response.success;
  }

  async getGameState(matchId: string): Promise<GameSnapshot | null> {
    const response = await this.request<GameSnapshot>(`/api/game/state/${matchId}`);

    if (response.success && response.data) {
      return response.data;
    }
    return null;
  }

  async performGameAction(
    matchId: string,
    action: 'PAUSE' | 'RESUME' | 'SURRENDER'
  ): Promise<boolean> {
    const response = await this.request('/api/game/action', {
      method: 'POST',
      body: JSON.stringify({
        matchId,
        action,
      }),
    });

    return response.success;
  }

  async getTroopTypes(): Promise<any[]> {
    const response = await this.request<{ troops: any[] }>('/api/game/troops');

    if (response.success && response.data) {
      return response.data.troops;
    }
    return [];
  }

  // Note: Player ID and name are now managed server-side via cookies
  // No need for client-side getters/setters
}

// Export singleton instance
export const apiClient = new ApiClient();

# ====== ui/src/services/gameClient.ts ======
import { apiClient } from './api';
import { WebSocketClient, ConnectionStatus } from './websocket';
import {
  GameSnapshot,
  GameStatus,
  PlayerState,
  TroopData,
  TowerData,
  CreateMatchResponse,
  JoinMatchResponse
} from '@/types/backend';

export interface GameClientOptions {
  onSnapshot?: (snapshot: GameSnapshot) => void;
  onStatusChange?: (status: ConnectionStatus) => void;
  onGameEnd?: (winner: 'red' | 'blue' | 'draw') => void;
  onError?: (error: Error) => void;
}

export class GameClient {
  private wsClient: WebSocketClient;
  private currentMatchId: string | null = null;
  private currentSnapshot: GameSnapshot | null = null;
  private playerState: PlayerState | null = null;
  private options: GameClientOptions;
  private isHost: boolean = false;

  constructor(options: GameClientOptions = {}) {
    this.options = options;

    this.wsClient = new WebSocketClient({
      onSnapshot: (snapshot) => this.handleSnapshot(snapshot),
      onStatusChange: (status) => this.options.onStatusChange?.(status),
      onError: (error) => this.options.onError?.(error),
    });
  }

  // Match Management
  async createMatch(): Promise<boolean> {
    try {
      const response = await apiClient.createMatch();
      if (!response) {
        throw new Error('Failed to create match');
      }

      this.currentMatchId = response.matchId;
      this.isHost = true;

      // Store player info if available
      if (response.playerState) {
        this.playerState = response.playerState;
        sessionStorage.setItem('playerId', response.playerState.id);
        sessionStorage.setItem('playerName', response.playerState.name);
      }

      // Connect to WebSocket
      const wsUrl = this.buildWebSocketUrl(response.wsUrl);
      this.wsClient.connect(wsUrl);

      return true;
    } catch (error) {
      console.error('Failed to create match:', error);
      this.options.onError?.(error as Error);
      return false;
    }
  }

  async joinMatch(matchId: string): Promise<boolean> {
    try {
      const response = await apiClient.joinMatch(matchId);
      if (!response) {
        throw new Error('Failed to join match');
      }

      this.currentMatchId = matchId;
      this.playerState = response.playerState;
      this.isHost = false;

      // Store player ID in sessionStorage for later use
      if (response.playerState) {
        sessionStorage.setItem('playerId', response.playerState.id);
        sessionStorage.setItem('playerName', response.playerState.name);
      }

      // Connect to WebSocket
      const wsUrl = this.buildWebSocketUrl(response.wsUrl);
      this.wsClient.connect(wsUrl);

      return true;
    } catch (error) {
      console.error('Failed to join match:', error);
      this.options.onError?.(error as Error);
      return false;
    }
  }

  private buildWebSocketUrl(baseUrl: string): string {
    // The WebSocket URL is now provided complete by the server
    // It already includes the correct player ID and room ID
    return baseUrl.replace('http://', 'ws://').replace('https://', 'wss://');
  }

  // Game Actions
  playCard(troopType: string, row: number, col: number): void {
    if (!this.currentMatchId) {
      console.error('No active match');
      return;
    }

    // Check if player has enough elixir
    if (this.playerState && !this.canPlayCard(troopType)) {
      console.warn('Not enough elixir to play card');
      return;
    }

    // Send via WebSocket for real-time update
    this.wsClient.playCard(troopType, { row, col });

    // REST API backup disabled - endpoint doesn't exist
    // apiClient.playCard(this.currentMatchId, troopType, { row, col });
  }

  private canPlayCard(troopType: string): boolean {
    if (!this.playerState) return false;

    // Check elixir cost (you'll need to import troop configs)
    const troopCosts: Record<string, number> = {
      'giant': 5,
      'babyDragon': 4,
      'miniPekka': 4,
      'valkyrie': 4
    };

    const cost = troopCosts[troopType] || 0;
    return this.playerState.elixir >= cost;
  }

  pauseGame(): void {
    if (!this.currentMatchId) return;

    this.wsClient.sendGameAction('PAUSE');
    // REST API backup disabled - endpoint doesn't exist
    // apiClient.performGameAction(this.currentMatchId, 'PAUSE');
  }

  resumeGame(): void {
    if (!this.currentMatchId) return;

    this.wsClient.sendGameAction('RESUME');
    // REST API backup disabled - endpoint doesn't exist
    // apiClient.performGameAction(this.currentMatchId, 'RESUME');
  }

  surrender(): void {
    if (!this.currentMatchId) return;

    this.wsClient.sendGameAction('SURRENDER');
    // REST API backup disabled - endpoint doesn't exist
    // apiClient.performGameAction(this.currentMatchId, 'SURRENDER');
  }

  // State Management
  private handleSnapshot(snapshot: GameSnapshot): void {
    this.currentSnapshot = snapshot;

    // Update player state - get player ID from sessionStorage
    const playerId = sessionStorage.getItem('playerId');
    if (playerId) {
      const player = snapshot.players.find(p => p.id === playerId);
      if (player) {
        this.playerState = player;
      }
    }

    // Check for game end
    if (snapshot.status === GameStatus.ENDED && snapshot.winner) {
      this.options.onGameEnd?.(snapshot.winner);
    }

    // Forward to callback
    this.options.onSnapshot?.(snapshot);
  }

  // Getters
  getSnapshot(): GameSnapshot | null {
    return this.currentSnapshot;
  }

  getTroops(): TroopData[] {
    return this.currentSnapshot?.troops || [];
  }

  getTowers(): TowerData[] {
    return this.currentSnapshot?.towers || [];
  }

  getPlayers(): PlayerState[] {
    return this.currentSnapshot?.players || [];
  }

  getPlayerState(): PlayerState | null {
    return this.playerState;
  }

  getPlayerTeam(): 'red' | 'blue' | null {
    return this.playerState?.team || null;
  }

  getPlayerElixir(): number {
    return this.playerState?.elixir || 0;
  }

  getGameStatus(): GameStatus | null {
    return this.currentSnapshot?.status || null;
  }

  getGameTime(): number {
    return this.currentSnapshot?.gameTime || 0;
  }

  getMatchId(): string | null {
    return this.currentMatchId;
  }

  isConnected(): boolean {
    return this.wsClient.isConnected();
  }

  getConnectionStatus(): ConnectionStatus {
    return this.wsClient.getStatus();
  }

  // Cleanup
  disconnect(): void {
    this.wsClient.disconnect();
    this.currentMatchId = null;
    this.currentSnapshot = null;
    this.playerState = null;
    this.isHost = false;
  }

  destroy(): void {
    this.disconnect();
  }
}

// Export singleton for easy use
export const gameClient = new GameClient();

# ====== ui/src/services/websocket.ts ======
import {
  WSMessage,
  WSMessageType,
  GameSnapshot,
  PlayCardData
} from '@/types/backend';

export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';

export interface WebSocketOptions {
  onSnapshot?: (snapshot: GameSnapshot) => void;
  onStatusChange?: (status: ConnectionStatus) => void;
  onError?: (error: Error) => void;
  onMessage?: (message: WSMessage) => void;
}

export class WebSocketClient {
  private ws: WebSocket | null = null;
  private url: string = '';
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private pingInterval: NodeJS.Timeout | null = null;
  private status: ConnectionStatus = 'disconnected';
  private options: WebSocketOptions;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000; // Start with 1 second

  constructor(options: WebSocketOptions = {}) {
    this.options = options;
  }

  connect(wsUrl: string): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      console.warn('WebSocket already connected');
      return;
    }

    this.url = wsUrl;
    this.reconnectAttempts = 0;
    this.establishConnection();
  }

  private establishConnection(): void {
    try {
      this.updateStatus('connecting');
      this.ws = new WebSocket(this.url);

      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.updateStatus('connected');
        this.reconnectAttempts = 0;
        this.reconnectDelay = 1000;
        this.startPingInterval();
      };

      this.ws.onmessage = (event) => {
        try {
          const message: WSMessage = JSON.parse(event.data);
          this.handleMessage(message);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        this.updateStatus('error');
        this.options.onError?.(new Error('WebSocket connection error'));
      };

      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
        this.updateStatus('disconnected');
        this.stopPingInterval();
        this.attemptReconnect();
      };
    } catch (error) {
      console.error('Failed to establish WebSocket connection:', error);
      this.updateStatus('error');
      this.attemptReconnect();
    }
  }

  private handleMessage(message: WSMessage): void {
    this.options.onMessage?.(message);

    switch (message.type) {
      case WSMessageType.GAME_SNAPSHOT:
        if (message.data?.snapshot) {
          this.options.onSnapshot?.(message.data.snapshot);
        }
        break;

      case WSMessageType.ERROR:
        console.error('Server error:', message.data);
        this.options.onError?.(new Error(message.data?.message || 'Server error'));
        break;

      case WSMessageType.PONG:
        // Heartbeat response received
        break;

      default:
        // Handle other message types if needed
        break;
    }
  }

  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      this.updateStatus('error');
      return;
    }

    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    this.reconnectAttempts++;
    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);

    console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

    this.reconnectTimeout = setTimeout(() => {
      this.establishConnection();
    }, delay);
  }

  private startPingInterval(): void {
    this.stopPingInterval();
    this.pingInterval = setInterval(() => {
      this.sendPing();
    }, 30000); // Ping every 30 seconds
  }

  private stopPingInterval(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }

  private sendPing(): void {
    this.send({
      type: WSMessageType.PING,
      timestamp: Date.now()
    });
  }

  private updateStatus(status: ConnectionStatus): void {
    this.status = status;
    this.options.onStatusChange?.(status);
  }

  send(message: WSMessage): void {
    if (this.ws?.readyState !== WebSocket.OPEN) {
      console.warn('Cannot send message: WebSocket not connected');
      return;
    }

    try {
      this.ws.send(JSON.stringify(message));
    } catch (error) {
      console.error('Failed to send WebSocket message:', error);
    }
  }

  playCard(troopType: string, position: { row: number; col: number }): void {
    this.send({
      type: WSMessageType.PLAY_CARD,
      timestamp: Date.now(),
      data: {
        troopType,
        position
      } as PlayCardData
    });
  }

  sendGameAction(action: string): void {
    this.send({
      type: WSMessageType.GAME_ACTION,
      timestamp: Date.now(),
      data: { action }
    });
  }

  disconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }

    this.stopPingInterval();

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }

    this.updateStatus('disconnected');
  }

  getStatus(): ConnectionStatus {
    return this.status;
  }

  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}

# ====== ui/src/types/backend.ts ======
// Types shared with backend server

export interface Position {
  row: number;
  col: number;
}

export enum TroopState {
  SPAWNING = 'SPAWNING',
  MOVING_TO_BRIDGE = 'MOVING_TO_BRIDGE',
  TARGETING_TOWER = 'TARGETING_TOWER',
  ATTACKING_TOWER = 'ATTACKING_TOWER',
  DEAD = 'DEAD'
}

export interface TroopData {
  id: string;
  type: string;
  team: 'red' | 'blue';
  position: Position;
  targetPosition: Position;
  state: TroopState;
  health: number;
  maxHealth: number;
  speed: number;
  isAlive: boolean;
  bridgeTarget?: Position;
  towerTarget?: string;
  isInCombat: boolean;
  attackDamage: number;
  attackSpeed: number;
  lastAttackTime: number;
  focusOnBuildings: boolean;
  flying: boolean;
  row: number;
  col: number;
  spawnTime: number;
  lastUpdateTime: number;
}

export interface TowerData {
  id: string;
  type: 'king' | 'princess';
  team: 'red' | 'blue';
  position: Position;
  health: number;
  maxHealth: number;
  isAlive: boolean;
  active: boolean;
  damage: number;
  attackSpeed: number;
  range: number;
  lastAttackTime: number;
}

export enum GameStatus {
  WAITING = 'WAITING',
  STARTING = 'STARTING',
  IN_PROGRESS = 'IN_PROGRESS',
  PAUSED = 'PAUSED',
  ENDED = 'ENDED'
}

export interface PlayerState {
  id: string;
  name: string;
  team: 'red' | 'blue';
  isConnected: boolean;
  elixir: number;
  maxElixir: number;
  elixirRegenRate: number;
  crowns: number;
  lastActionTime: number;
}

export interface GameSnapshot {
  timestamp: number;
  tick: number;
  status: GameStatus;
  gameTime: number;
  troops: TroopData[];
  towers: TowerData[];
  players: PlayerState[];
  winner?: 'red' | 'blue' | 'draw';
  endReason?: string;
}

// API Response types
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
  };
  timestamp: number;
}

export interface CreateMatchResponse {
  matchId: string;
  joinToken: string;
  wsUrl: string;
  playerState?: PlayerState; // Optional to maintain backward compatibility
}

export interface JoinMatchResponse {
  matchId: string;
  team: 'red' | 'blue';
  wsUrl: string;
  playerState: PlayerState;
}

export interface MatchInfo {
  id: string;
  playerCount: number;
  maxPlayers: number;
  status: GameStatus;
  createdAt: number;
  startedAt?: number;
  players: Array<{
    id: string;
    name: string;
    team: 'red' | 'blue';
    isConnected: boolean;
  }>;
}

// WebSocket message types
export enum WSMessageType {
  // Client -> Server
  JOIN_ROOM = 'JOIN_ROOM',
  LEAVE_ROOM = 'LEAVE_ROOM',
  PLAY_CARD = 'PLAY_CARD',
  GAME_ACTION = 'GAME_ACTION',
  PING = 'PING',

  // Server -> Client
  ROOM_JOINED = 'ROOM_JOINED',
  ROOM_LEFT = 'ROOM_LEFT',
  GAME_SNAPSHOT = 'GAME_SNAPSHOT',
  GAME_EVENT = 'GAME_EVENT',
  ERROR = 'ERROR',
  PONG = 'PONG'
}

export interface WSMessage {
  type: WSMessageType;
  timestamp: number;
  data?: any;
}

export interface PlayCardData {
  troopType: string;
  position: Position;
}
